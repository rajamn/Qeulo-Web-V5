import logging
from appointments.models import AppointmentDetails
from doctors.models import Doctor
import logging


from datetime import datetime, date, time, timedelta

def _parse_date_flexible(d) -> date:
    if isinstance(d, date):
        return d
    if not d:
        return date.today()
    s = str(d).strip()
    for fmt in ("%Y-%m-%d", "%d-%m-%Y"):
        try:
            return datetime.strptime(s, fmt).date()
        except ValueError:
            continue
    # fallback: today
    return date.today()

def normalize_time_input(start_time_input) -> time:
    """Ensures a clean time object without seconds/microseconds; accepts 'HH:MM' or 'HH:MM AM/PM'."""
    if isinstance(start_time_input, time):
        return start_time_input.replace(second=0, microsecond=0)
    if start_time_input is None:
        return time(18, 0)
    s = str(start_time_input).strip()
    for fmt in ("%H:%M", "%I:%M %p"):
        try:
            t = datetime.strptime(s, fmt).time()
            return t.replace(second=0, microsecond=0)
        except ValueError:
            continue
    return time(18, 0)  # Default fallback

def round_time_to_nearest_5min(t: time) -> time:
    dt = datetime.combine(date.today(), t)
    minutes = (dt.minute + 2) // 5 * 5
    rounded = dt.replace(minute=0, second=0, microsecond=0) + timedelta(minutes=minutes)
    return rounded.time()

def calculate_eta_time(start_time_input, avg_minutes: int, que_pos: int, appointment_on=None) -> time:
    """
    Calculate ETA for a given doctor, average time, and queue position.
    Uses 'now' only if appointment is today; otherwise starts from doctor's start_time.
    Accepts date/time as Python objects or strings (YYYY-MM-DD / DD-MM-YYYY; HH:MM / HH:MM AM/PM).
    """
    start_time = normalize_time_input(start_time_input)
    appt_date = _parse_date_flexible(appointment_on)
    now = datetime.now()

    effective_start = max(now.time(), start_time) if appt_date == now.date() else start_time
    base = datetime.combine(appt_date, effective_start)
    eta = base + timedelta(minutes=int(avg_minutes) * int(que_pos))
    return round_time_to_nearest_5min(eta.time().replace(second=0, microsecond=0))

from django.contrib.auth import authenticate, login,logout
from django.contrib.auth.decorators import login_required
from django.contrib.auth.views import LoginView
from django.shortcuts import render, redirect
from .forms import LoginForm
from django.urls import reverse_lazy
from django.contrib import messages
from core.forms import HospitalUserLoginForm
from django.views import View
from .forms import ProfileForm

class CustomLoginView(LoginView):
    template_name = 'core/login.html'
    authentication_form = HospitalUserLoginForm
    redirect_authenticated_user = True

    def form_valid(self, form):
        user = form.get_user()
        login(self.request, user)

        if user.must_change_password:
            return redirect('change_password')

        return redirect(self.get_success_url())

    def get_success_url(self):
        # Always send authenticated users to queue dashboard
        return "/queue/"



@login_required
def change_password(request):
    if request.method == "POST":
        new_password = request.POST.get("new_password")
        confirm_password = request.POST.get("confirm_password")

        if new_password and new_password == confirm_password:
            user = request.user
            user.set_password(new_password)
            user.must_change_password = False
            user.save()

            logout(request)  # ‚úÖ safely log out after saving
            messages.success(request, "‚úÖ Password changed successfully. Please log in again.")
            return redirect('login')  # ‚úÖ redirect immediately

        else:
            messages.error(request, "‚ùå Passwords do not match.")

    return render(request, "change_password.html")

def logout_view(request):
    logout(request)
    return redirect('login')  # or replace with any page you want after logout





@login_required
def profile(request):
    # Bind the form directly to the user instance
    if request.method == 'POST':
        form = ProfileForm(request.POST, instance=request.user)
        if form.is_valid():
            form.save()
            return redirect('profile')
    else:
        form = ProfileForm(instance=request.user)

    return render(request, 'core/profile.html', {
        'form': form
    })


# in views.py
from django.http import HttpResponse

def health_check(request):
    return HttpResponse("OK", status=200)


class RootRedirectView(View):
    def get(self, request, *args, **kwargs):
        if request.user.is_authenticated:
            return redirect("/queue/")   # use hardcoded path
        return redirect("login")         # safe, since login is named


# core/views.py
import json
import logging
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt

logger = logging.getLogger(__name__)

@csrf_exempt
def doubletick_webhook(request):
    if request.method == "POST":
        try:
            payload = json.loads(request.body.decode("utf-8"))
            logger.info("DoubleTick Webhook: %s", payload)
            print("üî• Webhook received:", payload)  # also shows up in runserver console
            return JsonResponse({"status": "ok"})
        except Exception as e:
            logger.error("Webhook error: %s", e)
            return JsonResponse({"error": str(e)}, status=400)
    return JsonResponse({"detail": "Method not allowed"}, status=405)
